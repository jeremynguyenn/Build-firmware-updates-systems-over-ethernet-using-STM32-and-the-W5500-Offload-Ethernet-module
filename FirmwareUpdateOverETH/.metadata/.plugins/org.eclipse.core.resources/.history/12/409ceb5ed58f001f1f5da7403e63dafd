#include <stdio.h>
#include "stm32f4xx.h"
#include "fpu.h"
#include "uart.h"
#include "timebase.h"
#include "bsp.h"
#include "adc.h"
#include "w5500_driver.h"
#include "dns.h"
#include "httpClient.h"
#include "firmware_updater.h"

#define SOCK_DNS	4
#define SOCK_HTTP_CLIENT	1
#define HTTP_PORT		80

#define HTTP_GET_BIN_REQUEST   "/releases/firmware-v1019.bin"
#define HTTP_GET_TXT_REQUEST "/releases/firmware_version.txt"


int8_t process_dns(void);

 typedef enum
 {
	 FLG_RESET = 0,
	 FLG_SET = 1
 }dns_state_type;


uint8_t flag_process_dns_success =  FLG_RESET;
uint8_t flag_http_request_sent = FLG_RESET;

uint8_t dns_server[4] = {8,8,8,8};
uint8_t domain_ip[4] = {};

uint8_t domain_name[]= "embedexpert-fota.batcave.net";

uint8_t data_buff[DATA_BUF_SIZE];
uint8_t g_send_buff[DATA_BUF_SIZE];
uint8_t g_recv_buff[DATA_BUF_SIZE];

uint32_t firmware_size;
char firmware_buffer[MAX_FIRMWARE_SIZE] = {0};

wiz_PhyConf current_phy_conf;

void check_cable_connection(void)
{
	uint8_t cable_status;

	do{

		printf("\r\nGetting cable status...\r\n");
		ctlwizchip(CW_GET_PHYLINK,(void *)&cable_status);

		if(cable_status ==  PHY_LINK_OFF)
		{
			printf("No cable detected ...\r\n");
			delay(1000);
		}

	}while(cable_status ==  PHY_LINK_OFF);

	printf("Cable connected...\r\n");

}

void display_phy_config(void)
{
	wiz_PhyConf phy_conf;
	ctlwizchip(CW_GET_PHYCONF,(void*)&phy_conf);

	if(phy_conf.by == PHY_CONFBY_HW)
	{
		printf("\n\rPHY is currently configured by hardware.");
	}
	else{
		printf("\n\rPHY is currently configured by software.");

	}
	printf("\r\nSTATUS: Autonegotiation %s",(phy_conf.mode == PHY_MODE_AUTONEGO) ? "Enabled" : "Disabled");
	printf("\r\nSTATUS: Duplex Mode: %s",(phy_conf.duplex == PHY_DUPLEX_FULL) ? "Full Duplex" : "Half Duplex");
	printf("\r\nSTATUS: Speed: %dMbps",(phy_conf.speed == PHY_SPEED_10) ? 10 : 100);
  printf("\r\n...");

}

int main()
{

	uint16_t len = 0;

	/*Enable FPU*/
	fpu_enable();

	/*Initialize timebase*/
	timebase_init();

	/*Initialize debug UART*/
	debug_uart_init();



	/*Initialize LED*/
	led_init();

	/*Initialize Push button*/
	button_init();

	/*Initialize ADC*/
	pa1_adc_init();

	/*Start conversion*/
	start_conversion();

    wizchip_cs_pin_init();
    w5500_spi_init();
    w5500_init();

    check_cable_connection();
    display_phy_config();


    /*Run DNS*/
    if(process_dns())
    {
    	flag_process_dns_success =  FLG_SET;
    }

    if(flag_process_dns_success)
    {
	    printf(" # DNS: %s => %d.%d.%d.%d\r\n", domain_name, domain_ip[0], domain_ip[1], domain_ip[2], domain_ip[3]);

    }
    else
    {
    	printf("DNS Failed\r\n");
    }

    /*Initialize http client*/
    httpc_init(SOCK_HTTP_CLIENT,domain_ip,HTTP_PORT,g_send_buff, g_recv_buff);

	while(1)
	{
		httpc_connection_handler();
		if(httpc_isSockOpen)
		{
			httpc_connect();
		}
		if(httpc_isConnected)
		{
		  if(flag_http_request_sent == FLG_RESET)
		  {

			  /*Get firmware update text file*/
			  request.method = (uint8_t *)HTTP_GET;
			  request.uri = (uint8_t *)HTTP_GET_BIN_REQUEST;
			  request.host = (uint8_t *)domain_name;

			  httpc_send(&request,g_recv_buff,g_send_buff,0);

			  flag_http_request_sent = FLG_SET;
		  }

		  /*Get received data length*/
		   httpc_isReceived =  getSn_RX_RSR(SOCK_HTTP_CLIENT);

		   if(httpc_isReceived > 0)
		   {


			   len =  httpc_recv(g_recv_buff, httpc_isReceived);
			   firmware_size =  extract_content_length((char *)g_recv_buff);

			   if(len > firmware_size)
			   {
				   //get_firmware_binary((char *)g_recv_buff, "stream\r\n\r\n", (char *)firmware_buffer,firmware_size);

				   get_firmware_binary((char *)g_recv_buff, "octet", (char *)firmware_buffer,firmware_size);

				   /*Write the firmware update to memory*/
				   firmware_update();

				   /*Jump to new memory location to run firmware*/
				   jump_to_app(NEW_FIRMWARE_START_ADDRESS);
			   }
		   }
		}
	}
}

int8_t process_dns(void)
{
	int8_t ret = 0;
	uint8_t dns_retry = 0;

	DNS_init(SOCK_DNS, data_buff);

	while(1)
	{
		if((  ret = DNS_run(dns_server, (uint8_t *)domain_name,domain_ip)) == 1)
		{
			break;
		}
		else
		{
			dns_retry++;
			if(dns_retry <= 2)
			{
				printf("DNS timeout occurred retry [%d]\n\r",dns_retry);
			}
			if(dns_retry > 2)
			{
				 break;
			}
		}
	}

	return ret;
}
